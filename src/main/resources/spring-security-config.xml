<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright 2012-2013 Manuel Schulze <manuel_schulze@i-entwicklung.de>
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:security="http://www.springframework.org/schema/security"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
  http://www.springframework.org/schema/security
  http://www.springframework.org/schema/security/spring-security-3.1.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">

    <!--
    Damit wir auch SpEL in JSPs verwenden können.
    -->
    <bean id="webexpressionHandler"
          class="org.springframework.security.web.access.expression.DefaultWebSecurityExpressionHandler"/>

    <!-- http://static.springsource.org/spring-security/site/docs/3.1.x/apidocs/org/springframework/security/access/hierarchicalroles/RoleHierarchyImpl.html -->
    <bean id="roleHierarchy" class="org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl">
        <property name="hierarchy">
            <value>
                ROLE_ADMIN > ROLE_USER
                ROLE_USER > ROLE_VISITOR
                ROLE_ADMIN > ROLE_SKETCHPAD_ADMIN
                ROLE_SKETCHPAD_ADMIN > ROLE_SKETCHPAD_USER
                ROLE_SKETCHPAD_USER > ROLE_SKETCHPAD_VISITOR
            </value>
        </property>
    </bean>

    <!--
    Damit wir die Urls nicht immer wiederholen müssen.
    -->
    <util:properties id="defaultUrls">
        <prop key="login">/identity/login.html</prop>
        <prop key="logout">/identity/logout.html</prop>
        <prop key="loginerror">/identity/loginerror.html</prop>
    </util:properties>

    <!--
    Definiere unsere Security-Filter-Chain. Sie wird unter der Id
    springSecurityFilterChain konfiguriert. Das ist Springs default Id und
    muss auch in der web.xml als Filter-Konfiguration angegeben werden. Man
    kann auch eine eigene Id verwenden.

    Der Link in die Spring-Dokumentation zeigt interessante Anwendungsfälle.

    see http://static.springsource.org/spring-security/site/docs/3.0.x/reference/security-filter-chain.html

    Laut XML-Beschreibung ist none ein gültiger Wert für filters. Scheinbar
    weiß IntelliJ das nicht.
    -->
    <bean id="springSecurityFilterChain" class="org.springframework.security.web.FilterChainProxy">
        <security:filter-chain-map path-type="ant">
            <security:filter-chain pattern="/**" filters="
            securityContextPersistenceFilter,
            logoutFilter,
            formAuthenticationFilter,
            anonymousAuthFilter,
            exceptionTranslationFilter,
            filterSecurityInterceptor"
                    />
        </security:filter-chain-map>
    </bean>

    <!--
    see http://static.springsource.org/spring-security/site/docs/3.0.x/reference/core-web-filters.html
    -->
    <bean id="exceptionTranslationFilter"
          class="org.springframework.security.web.access.ExceptionTranslationFilter">
        <property name="authenticationEntryPoint" ref="authenticationEntryPoint"/>
        <property name="accessDeniedHandler" ref="accessDeniedHandler"/>
    </bean>

    <bean id="accessDeniedHandler"
          class="org.springframework.security.web.access.AccessDeniedHandlerImpl">
        <property name="errorPage" value="/accessDenied.htm"/>
    </bean>

    <bean id="securityContextPersistenceFilter"
          class="org.springframework.security.web.context.SecurityContextPersistenceFilter">
        <property name='securityContextRepository' ref="sessionSecurityContextRepository"/>
    </bean>

    <bean id="sessionSecurityContextRepository"
          class='org.springframework.security.web.context.HttpSessionSecurityContextRepository'>
        <property name='allowSessionCreation' value='false'/>
    </bean>

    <bean id="sessionManagementFilter" class="org.springframework.security.web.session.SessionManagementFilter">
        <constructor-arg index="0" ref="sessionSecurityContextRepository"/>
        <constructor-arg index="1" ref="sas"/>
    </bean>

    <bean id="logoutFilter"
          class="org.springframework.security.web.authentication.logout.LogoutFilter">
        <constructor-arg value="/sketchpad.html"/>
        <constructor-arg>
            <list>
                <bean class="org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"/>
            </list>
        </constructor-arg>
        <property name="filterProcessesUrl" value="#{defaultUrls.logout}"/>
    </bean>

    <bean id="authenticationEntryPoint"
          class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">
        <constructor-arg index="0" value="#{defaultUrls.login}"/>
    </bean>

    <bean id="formAuthenticationFilter" class="de.iew.web.utils.ValidatingFormAuthenticationFilter">
        <property name="authenticationManager" ref="authenticationManager"/>
        <property name="filterProcessesUrl" value="#{defaultUrls.login}"/>
        <property name="authenticationSuccessHandler" ref="authenticationSuccessHandler"/>
        <property name="authenticationFailureHandler" ref="authenticationFailureHandler"/>
        <property name="sessionAuthenticationStrategy" ref="sas"/>
    </bean>

    <bean id="sas"
          class="org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy"/>

    <bean id="authenticationSuccessHandler"
          class="org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler">
        <property name="defaultTargetUrl" value="/sketchpad.html"/>
        <property name="alwaysUseDefaultTargetUrl" value="true"/>
        <property name="useReferer" value="true"/>
    </bean>

    <bean id="authenticationFailureHandler"
          class="org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler">
        <property name="defaultFailureUrl" value="#{defaultUrls.loginerror}"/>
        <property name="useForward" value="true"/>
    </bean>

    <bean id="accessDecisionManager" class="org.springframework.security.access.vote.AffirmativeBased">
        <property name="allowIfAllAbstainDecisions" value="false"/>
        <constructor-arg>
            <list>
                <ref bean="webResourceAccessDecisionVoter"/>
                <bean class="org.springframework.security.access.vote.RoleVoter"/>
                <bean class="org.springframework.security.access.vote.AuthenticatedVoter"/>
            </list>
        </constructor-arg>
    </bean>

    <bean id="filterSecurityInterceptor"
          class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor">
        <property name="securityMetadataSource" ref="filterInvocationSecurityMetadata"/>
        <property name="authenticationManager" ref="authenticationManager"/>
        <property name="accessDecisionManager" ref="accessDecisionManager"/>
    </bean>

    <bean id="webResourceAccessEvaluator" class="de.iew.framework.security.access.WebResourceAccessEvaluator">
        <property name="roleHierarchy" ref="roleHierarchy"/>
    </bean>

    <bean id="webResourceAccessDecisionVoter" class="de.iew.framework.security.access.WebResourceAccessDecisionVoter">
        <property name="webResourceAccessEvaluator" ref="webResourceAccessEvaluator"/>
    </bean>

    <bean id="filterInvocationSecurityMetadata"
          class="de.iew.services.impl.WebResourceSecurityServiceImpl">
    </bean>

    <!--
    Nicht authentifizierte Nutzer bekommen trotzdem ein Authentification Objekt
    damit Spring Security trotzdem greift. Ohne diesen Filter würde alle
    Autorisationsprüfungen (auch die Prüfung der ACL-Regeln) ins leere laufen
    und eine Exception gemeldet.
    -->
    <bean id="anonymousAuthFilter"
          class="org.springframework.security.web.authentication.AnonymousAuthenticationFilter">
        <constructor-arg name="key" value="foobar" index="0"/>
        <constructor-arg name="principal" value="anonymous" index="1"/>
        <constructor-arg name="authorities" index="2">
            <list>
                <bean class="org.springframework.security.core.authority.SimpleGrantedAuthority">
                    <constructor-arg index="0" value="ROLE_ANONYMOUS"/>
                </bean>
                <bean class="org.springframework.security.core.authority.SimpleGrantedAuthority">
                    <constructor-arg index="0" value="ROLE_SKETCHPAD_VISITOR"/>
                </bean>
            </list>
        </constructor-arg>
    </bean>

    <bean id="anonymousAuthenticationProvider"
          class="org.springframework.security.authentication.AnonymousAuthenticationProvider">
        <constructor-arg index="0" value="foobar"/>
    </bean>

    <!--
    Der globale Spring AuthenticationManager.

    Das Alias ist wichtig. Sonst ist der AuthenticationManager in Spring nicht
    eindeutig definiert und Spring startet nicht ordnungsgemäß. Scheinbar
    scheinen mehrere Beans unter der id "authenticationManager" konfiguriert zu
    sein.
    -->
    <security:authentication-manager alias="authenticationManager">
        <security:authentication-provider user-service-ref="userDetailsService">
            <security:password-encoder ref="passwordEncoder"/>
        </security:authentication-provider>
    </security:authentication-manager>

    <!--
    Wir verwenden für den Anfang MD5. Später stellen wir dann auf stärkeres
    Hashing, Salzen und Mehrfachiterationen um.

    see http://www.heise.de/security/artikel/Passwoerter-unknackbar-speichern-1253931.html

    TODO: Auf stärkeres Hashing und Salz umstellen. PHP-Code portieren oder Spring Recherche
    -->
    <bean class="org.springframework.security.authentication.encoding.Md5PasswordEncoder" id="passwordEncoder"/>
</beans>